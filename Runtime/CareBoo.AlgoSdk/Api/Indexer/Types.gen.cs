//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using AlgoSdk.Indexer;
using AlgoSdk.LowLevel;
using Unity.Collections;
using UnityEngine;

namespace AlgoSdk.Indexer
{
    [AlgoApiObject, Serializable]
    public partial struct AssetHoldingsResponse
        : IEquatable<AssetHoldingsResponse>
    {
        [SerializeField, Tooltip(@"")]
        AssetHolding[] @assets;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("assets")]
        public AssetHolding[] Assets
        {
            get => this.@assets;
            set => this.@assets = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(AssetHoldingsResponse other)
        {
            return 
                ArrayComparer.Equals(Assets, other.Assets) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationResponse
        : IEquatable<ApplicationResponse>
    {
        [SerializeField, Tooltip(@"")]
        Application @application;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("application")]
        public Application Application
        {
            get => this.@application;
            set => this.@application = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        public bool Equals(ApplicationResponse other)
        {
            return 
                Application.Equals(other.Application) &&
                CurrentRound.Equals(other.CurrentRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionsResponse
        : IEquatable<TransactionsResponse>
    {
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        [SerializeField, Tooltip(@"")]
        Transaction[] @transactions;
        
        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("transactions")]
        public Transaction[] Transactions
        {
            get => this.@transactions;
            set => this.@transactions = value;
        }

        public bool Equals(TransactionsResponse other)
        {
            return 
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken) &&
                ArrayComparer.Equals(Transactions, other.Transactions)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountsResponse
        : IEquatable<AccountsResponse>
    {
        [SerializeField, Tooltip(@"")]
        Account[] @accounts;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("accounts")]
        public Account[] Accounts
        {
            get => this.@accounts;
            set => this.@accounts = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(AccountsResponse other)
        {
            return 
                ArrayComparer.Equals(Accounts, other.Accounts) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetResponse
        : IEquatable<AssetResponse>
    {
        [SerializeField, Tooltip(@"")]
        Asset @asset;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset")]
        public Asset Asset
        {
            get => this.@asset;
            set => this.@asset = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        public bool Equals(AssetResponse other)
        {
            return 
                Asset.Equals(other.Asset) &&
                CurrentRound.Equals(other.CurrentRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetBalancesResponse
        : IEquatable<AssetBalancesResponse>
    {
        [SerializeField, Tooltip(@"")]
        MiniAssetHolding[] @balances;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("balances")]
        public MiniAssetHolding[] Balances
        {
            get => this.@balances;
            set => this.@balances = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(AssetBalancesResponse other)
        {
            return 
                ArrayComparer.Equals(Balances, other.Balances) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountResponse
        : IEquatable<AccountResponse>
    {
        [SerializeField, Tooltip(@"")]
        Account @account;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("account")]
        public Account Account
        {
            get => this.@account;
            set => this.@account = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        public bool Equals(AccountResponse other)
        {
            return 
                Account.Equals(other.Account) &&
                CurrentRound.Equals(other.CurrentRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationsResponse
        : IEquatable<ApplicationsResponse>
    {
        [SerializeField, Tooltip(@"")]
        Application[] @applications;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("applications")]
        public Application[] Applications
        {
            get => this.@applications;
            set => this.@applications = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(ApplicationsResponse other)
        {
            return 
                ArrayComparer.Equals(Applications, other.Applications) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionResponse
        : IEquatable<TransactionResponse>
    {
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"")]
        Transaction @transaction;
        
        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("transaction")]
        public Transaction Transaction
        {
            get => this.@transaction;
            set => this.@transaction = value;
        }

        public bool Equals(TransactionResponse other)
        {
            return 
                CurrentRound.Equals(other.CurrentRound) &&
                Transaction.Equals(other.Transaction)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLogsResponse
        : IEquatable<ApplicationLogsResponse>
    {
        [SerializeField, Tooltip(@"[appidx] application index.")]
        ulong @applicationId;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"")]
        ApplicationLogData[] @logData;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        /// [appidx] application index.        
        /// </summary>
        [AlgoApiField("application-id")]
        public ulong ApplicationId
        {
            get => this.@applicationId;
            set => this.@applicationId = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("log-data")]
        public ApplicationLogData[] LogData
        {
            get => this.@logData;
            set => this.@logData = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(ApplicationLogsResponse other)
        {
            return 
                ApplicationId.Equals(other.ApplicationId) &&
                CurrentRound.Equals(other.CurrentRound) &&
                ArrayComparer.Equals(LogData, other.LogData) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetsResponse
        : IEquatable<AssetsResponse>
    {
        [SerializeField, Tooltip(@"")]
        Asset[] @assets;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("assets")]
        public Asset[] Assets
        {
            get => this.@assets;
            set => this.@assets = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(AssetsResponse other)
        {
            return 
                ArrayComparer.Equals(Assets, other.Assets) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ErrorResponse
        : IEquatable<ErrorResponse>
    {
        [SerializeField, Tooltip(@"")]
        AlgoApiObject @data;
        
        [SerializeField, Tooltip(@"")]
        string @message;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("data")]
        public AlgoApiObject Data
        {
            get => this.@data;
            set => this.@data = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("message")]
        public string Message
        {
            get => this.@message;
            set => this.@message = value;
        }

        public bool Equals(ErrorResponse other)
        {
            return 
                Data.Equals(other.Data) &&
                StringComparer.Equals(Message, other.Message)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLocalStatesResponse
        : IEquatable<ApplicationLocalStatesResponse>
    {
        [SerializeField, Tooltip(@"")]
        ApplicationLocalState[] @appsLocalStates;
        
        [SerializeField, Tooltip(@"Round at which the results were computed.")]
        ulong @currentRound;
        
        [SerializeField, Tooltip(@"Used for pagination, when making another request provide this token with the next parameter.")]
        string @nextToken;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("apps-local-states")]
        public ApplicationLocalState[] AppsLocalStates
        {
            get => this.@appsLocalStates;
            set => this.@appsLocalStates = value;
        }

        /// <summary>
        /// Round at which the results were computed.        
        /// </summary>
        [AlgoApiField("current-round")]
        public ulong CurrentRound
        {
            get => this.@currentRound;
            set => this.@currentRound = value;
        }

        /// <summary>
        /// Used for pagination, when making another request provide this token with the next parameter.        
        /// </summary>
        [AlgoApiField("next-token")]
        public string NextToken
        {
            get => this.@nextToken;
            set => this.@nextToken = value;
        }

        public bool Equals(ApplicationLocalStatesResponse other)
        {
            return 
                ArrayComparer.Equals(AppsLocalStates, other.AppsLocalStates) &&
                CurrentRound.Equals(other.CurrentRound) &&
                StringComparer.Equals(NextToken, other.NextToken)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Block
        : IEquatable<Block>
    {
        [SerializeField, Tooltip(@"")]
        BlockRewards @rewards;
        
        [SerializeField, Tooltip(@"[gh] hash to which this block belongs.")]
        string @genesisHash;
        
        [SerializeField, Tooltip(@"")]
        BlockUpgradeState @upgradeState;
        
        [SerializeField, Tooltip(@"[prev] Previous block hash.")]
        string @previousBlockHash;
        
        [SerializeField, Tooltip(@"[seed] Sortition seed.")]
        string @seed;
        
        [SerializeField, Tooltip(@"[rnd] Current round on which this block was appended to the chain.")]
        ulong @round;
        
        [SerializeField, Tooltip(@"[txn] TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it's the root of a merkle tree whose leaves are the block's Txids, in lexicographic order. For the empty block, it's 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.")]
        string @transactionsRoot;
        
        [SerializeField, Tooltip(@"[gen] ID to which this block belongs.")]
        string @genesisId;
        
        [SerializeField, Tooltip(@"")]
        BlockUpgradeVote @upgradeVote;
        
        [SerializeField, Tooltip(@"[txns] list of transactions corresponding to a given round.")]
        Transaction[] @transactions;
        
        [SerializeField, Tooltip(@"[ts] Block creation timestamp in seconds since eposh")]
        ulong @timestamp;
        
        [SerializeField, Tooltip(@"[tc] TxnCounter counts the number of transactions committed in the ledger, from the time at which support for this feature was introduced.

Specifically, TxnCounter is the number of the next transaction that will be committed after this block.  It is 0 when no transactions have ever been committed (since TxnCounter started being supported).")]
        ulong @txnCounter;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("rewards")]
        public BlockRewards Rewards
        {
            get => this.@rewards;
            set => this.@rewards = value;
        }

        /// <summary>
        /// [gh] hash to which this block belongs.        
        /// </summary>
        [AlgoApiField("genesis-hash")]
        public string GenesisHash
        {
            get => this.@genesisHash;
            set => this.@genesisHash = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("upgrade-state")]
        public BlockUpgradeState UpgradeState
        {
            get => this.@upgradeState;
            set => this.@upgradeState = value;
        }

        /// <summary>
        /// [prev] Previous block hash.        
        /// </summary>
        [AlgoApiField("previous-block-hash")]
        public string PreviousBlockHash
        {
            get => this.@previousBlockHash;
            set => this.@previousBlockHash = value;
        }

        /// <summary>
        /// [seed] Sortition seed.        
        /// </summary>
        [AlgoApiField("seed")]
        public string Seed
        {
            get => this.@seed;
            set => this.@seed = value;
        }

        /// <summary>
        /// [rnd] Current round on which this block was appended to the chain.        
        /// </summary>
        [AlgoApiField("round")]
        public ulong Round
        {
            get => this.@round;
            set => this.@round = value;
        }

        /// <summary>
        /// [txn] TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it's the root of a merkle tree whose leaves are the block's Txids, in lexicographic order. For the empty block, it's 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.        
        /// </summary>
        [AlgoApiField("transactions-root")]
        public string TransactionsRoot
        {
            get => this.@transactionsRoot;
            set => this.@transactionsRoot = value;
        }

        /// <summary>
        /// [gen] ID to which this block belongs.        
        /// </summary>
        [AlgoApiField("genesis-id")]
        public string GenesisId
        {
            get => this.@genesisId;
            set => this.@genesisId = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("upgrade-vote")]
        public BlockUpgradeVote UpgradeVote
        {
            get => this.@upgradeVote;
            set => this.@upgradeVote = value;
        }

        /// <summary>
        /// [txns] list of transactions corresponding to a given round.        
        /// </summary>
        [AlgoApiField("transactions")]
        public Transaction[] Transactions
        {
            get => this.@transactions;
            set => this.@transactions = value;
        }

        /// <summary>
        /// [ts] Block creation timestamp in seconds since eposh        
        /// </summary>
        [AlgoApiField("timestamp")]
        public ulong Timestamp
        {
            get => this.@timestamp;
            set => this.@timestamp = value;
        }

        /// <summary>
        /// [tc] TxnCounter counts the number of transactions committed in the ledger, from the time at which support for this feature was introduced.
        /// 
        /// Specifically, TxnCounter is the number of the next transaction that will be committed after this block.  It is 0 when no transactions have ever been committed (since TxnCounter started being supported).        
        /// </summary>
        [AlgoApiField("txn-counter")]
        public ulong TxnCounter
        {
            get => this.@txnCounter;
            set => this.@txnCounter = value;
        }

        public bool Equals(Block other)
        {
            return 
                Rewards.Equals(other.Rewards) &&
                StringComparer.Equals(GenesisHash, other.GenesisHash) &&
                UpgradeState.Equals(other.UpgradeState) &&
                StringComparer.Equals(PreviousBlockHash, other.PreviousBlockHash) &&
                StringComparer.Equals(Seed, other.Seed) &&
                Round.Equals(other.Round) &&
                StringComparer.Equals(TransactionsRoot, other.TransactionsRoot) &&
                StringComparer.Equals(GenesisId, other.GenesisId) &&
                UpgradeVote.Equals(other.UpgradeVote) &&
                ArrayComparer.Equals(Transactions, other.Transactions) &&
                Timestamp.Equals(other.Timestamp) &&
                TxnCounter.Equals(other.TxnCounter)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignatureMultisig
        : IEquatable<TransactionSignatureMultisig>
    {
        [SerializeField, Tooltip(@"[subsig] holds pairs of public key and signatures.")]
        TransactionSignatureMultisigSubsignature[] @subsignature;
        
        [SerializeField, Tooltip(@"[thr]")]
        ulong @threshold;
        
        [SerializeField, Tooltip(@"[v]")]
        ulong @version;
        
        /// <summary>
        /// [subsig] holds pairs of public key and signatures.        
        /// </summary>
        [AlgoApiField("subsignature")]
        public TransactionSignatureMultisigSubsignature[] Subsignature
        {
            get => this.@subsignature;
            set => this.@subsignature = value;
        }

        /// <summary>
        /// [thr]        
        /// </summary>
        [AlgoApiField("threshold")]
        public ulong Threshold
        {
            get => this.@threshold;
            set => this.@threshold = value;
        }

        /// <summary>
        /// [v]        
        /// </summary>
        [AlgoApiField("version")]
        public ulong Version
        {
            get => this.@version;
            set => this.@version = value;
        }

        public bool Equals(TransactionSignatureMultisig other)
        {
            return 
                ArrayComparer.Equals(Subsignature, other.Subsignature) &&
                Threshold.Equals(other.Threshold) &&
                Version.Equals(other.Version)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationParams
        : IEquatable<ApplicationParams>
    {
        [SerializeField, Tooltip(@"[approv] approval program.")]
        CompiledTeal @approvalProgram;
        
        [SerializeField, Tooltip(@"[clearp] approval program.")]
        CompiledTeal @clearStateProgram;
        
        [SerializeField, Tooltip(@"The address that created this application. This is the address where the parameters and global state for this application can be found.")]
        Address @creator;
        
        [SerializeField, Tooltip(@"[epp] the amount of extra program pages available to this app.")]
        ulong @extraProgramPages;
        
        [SerializeField, Tooltip(@"")]
        TealKeyValueStore @globalState;
        
        [SerializeField, Tooltip(@"")]
        ApplicationStateSchema @globalStateSchema;
        
        [SerializeField, Tooltip(@"")]
        ApplicationStateSchema @localStateSchema;
        
        /// <summary>
        /// [approv] approval program.        
        /// </summary>
        [AlgoApiField("approval-program")]
        public CompiledTeal ApprovalProgram
        {
            get => this.@approvalProgram;
            set => this.@approvalProgram = value;
        }

        /// <summary>
        /// [clearp] approval program.        
        /// </summary>
        [AlgoApiField("clear-state-program")]
        public CompiledTeal ClearStateProgram
        {
            get => this.@clearStateProgram;
            set => this.@clearStateProgram = value;
        }

        /// <summary>
        /// The address that created this application. This is the address where the parameters and global state for this application can be found.        
        /// </summary>
        [AlgoApiField("creator")]
        public Address Creator
        {
            get => this.@creator;
            set => this.@creator = value;
        }

        /// <summary>
        /// [epp] the amount of extra program pages available to this app.        
        /// </summary>
        [AlgoApiField("extra-program-pages")]
        public ulong ExtraProgramPages
        {
            get => this.@extraProgramPages;
            set => this.@extraProgramPages = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("global-state")]
        public TealKeyValueStore GlobalState
        {
            get => this.@globalState;
            set => this.@globalState = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("global-state-schema")]
        public ApplicationStateSchema GlobalStateSchema
        {
            get => this.@globalStateSchema;
            set => this.@globalStateSchema = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("local-state-schema")]
        public ApplicationStateSchema LocalStateSchema
        {
            get => this.@localStateSchema;
            set => this.@localStateSchema = value;
        }

        public bool Equals(ApplicationParams other)
        {
            return 
                ApprovalProgram.Equals(other.ApprovalProgram) &&
                ClearStateProgram.Equals(other.ClearStateProgram) &&
                Creator.Equals(other.Creator) &&
                ExtraProgramPages.Equals(other.ExtraProgramPages) &&
                GlobalState.Equals(other.GlobalState) &&
                GlobalStateSchema.Equals(other.GlobalStateSchema) &&
                LocalStateSchema.Equals(other.LocalStateSchema)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TealValue
        : IEquatable<TealValue>
    {
        [SerializeField, Tooltip(@"[tb] bytes value.")]
        string @bytes;
        
        [SerializeField, Tooltip(@"[tt] value type. Value `1` refers to **bytes**, value `2` refers to **uint**")]
        ulong @type;
        
        [SerializeField, Tooltip(@"[ui] uint value.")]
        ulong @uint;
        
        /// <summary>
        /// [tb] bytes value.        
        /// </summary>
        [AlgoApiField("bytes")]
        public string Bytes
        {
            get => this.@bytes;
            set => this.@bytes = value;
        }

        /// <summary>
        /// [tt] value type. Value `1` refers to **bytes**, value `2` refers to **uint**        
        /// </summary>
        [AlgoApiField("type")]
        public ulong Type
        {
            get => this.@type;
            set => this.@type = value;
        }

        /// <summary>
        /// [ui] uint value.        
        /// </summary>
        [AlgoApiField("uint")]
        public ulong Uint
        {
            get => this.@uint;
            set => this.@uint = value;
        }

        public bool Equals(TealValue other)
        {
            return 
                StringComparer.Equals(Bytes, other.Bytes) &&
                Type.Equals(other.Type) &&
                Uint.Equals(other.Uint)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignatureLogicsig
        : IEquatable<TransactionSignatureLogicsig>
    {
        [SerializeField, Tooltip(@"[arg] Logic arguments, base64 encoded.")]
        string[] @args;
        
        [SerializeField, Tooltip(@"[l] Program signed by a signature or multi signature, or hashed to be the address of ana ccount. Base64 encoded TEAL program.")]
        string @logic;
        
        [SerializeField, Tooltip(@"")]
        TransactionSignatureMultisig @multisigSignature;
        
        [SerializeField, Tooltip(@"[sig] ed25519 signature.")]
        string @signature;
        
        /// <summary>
        /// [arg] Logic arguments, base64 encoded.        
        /// </summary>
        [AlgoApiField("args")]
        public string[] Args
        {
            get => this.@args;
            set => this.@args = value;
        }

        /// <summary>
        /// [l] Program signed by a signature or multi signature, or hashed to be the address of ana ccount. Base64 encoded TEAL program.        
        /// </summary>
        [AlgoApiField("logic")]
        public string Logic
        {
            get => this.@logic;
            set => this.@logic = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("multisig-signature")]
        public TransactionSignatureMultisig MultisigSignature
        {
            get => this.@multisigSignature;
            set => this.@multisigSignature = value;
        }

        /// <summary>
        /// [sig] ed25519 signature.        
        /// </summary>
        [AlgoApiField("signature")]
        public string Signature
        {
            get => this.@signature;
            set => this.@signature = value;
        }

        public bool Equals(TransactionSignatureLogicsig other)
        {
            return 
                ArrayComparer.Equals(Args, other.Args) &&
                StringComparer.Equals(Logic, other.Logic) &&
                MultisigSignature.Equals(other.MultisigSignature) &&
                StringComparer.Equals(Signature, other.Signature)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct EvalDelta
        : IEquatable<EvalDelta>
    {
        [SerializeField, Tooltip(@"[at] delta action.")]
        ulong @action;
        
        [SerializeField, Tooltip(@"[bs] bytes value.")]
        string @bytes;
        
        [SerializeField, Tooltip(@"[ui] uint value.")]
        ulong @uint;
        
        /// <summary>
        /// [at] delta action.        
        /// </summary>
        [AlgoApiField("action")]
        public ulong Action
        {
            get => this.@action;
            set => this.@action = value;
        }

        /// <summary>
        /// [bs] bytes value.        
        /// </summary>
        [AlgoApiField("bytes")]
        public string Bytes
        {
            get => this.@bytes;
            set => this.@bytes = value;
        }

        /// <summary>
        /// [ui] uint value.        
        /// </summary>
        [AlgoApiField("uint")]
        public ulong Uint
        {
            get => this.@uint;
            set => this.@uint = value;
        }

        public bool Equals(EvalDelta other)
        {
            return 
                Action.Equals(other.Action) &&
                StringComparer.Equals(Bytes, other.Bytes) &&
                Uint.Equals(other.Uint)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionApplication
        : IEquatable<TransactionApplication>
    {
        [SerializeField, Tooltip(@"[apid] ID of the application being configured or empty if creating.")]
        ulong @applicationId;
        
        [SerializeField, Tooltip(@"[apap] Logic executed for every application transaction, except when on-completion is set to &quot;clear&quot;. It can read and write global state for the application, as well as account-specific local state. Approval programs may reject the transaction.")]
        CompiledTeal @approvalProgram;
        
        [SerializeField, Tooltip(@"[apfa] Lists the applications in addition to the application-id whose global states may be accessed by this application's approval-program and clear-state-program. The access is read-only.")]
        ulong[] @foreignApps;
        
        [SerializeField, Tooltip(@"[apaa] transaction specific arguments accessed from the application's approval-program and clear-state-program.")]
        string[] @applicationArgs;
        
        [SerializeField, Tooltip(@"")]
        OnCompletion @onCompletion;
        
        [SerializeField, Tooltip(@"")]
        StateSchema @globalStateSchema;
        
        [SerializeField, Tooltip(@"[epp] specifies the additional app program len requested in pages.")]
        ulong @extraProgramPages;
        
        [SerializeField, Tooltip(@"[apas] lists the assets whose parameters may be accessed by this application's ApprovalProgram and ClearStateProgram. The access is read-only.")]
        ulong[] @foreignAssets;
        
        [SerializeField, Tooltip(@"")]
        StateSchema @localStateSchema;
        
        [SerializeField, Tooltip(@"[apat] List of accounts in addition to the sender that may be accessed from the application's approval-program and clear-state-program.")]
        Address[] @accounts;
        
        [SerializeField, Tooltip(@"[apsu] Logic executed for application transactions with on-completion set to &quot;clear&quot;. It can read and write global state for the application, as well as account-specific local state. Clear state programs cannot reject the transaction.")]
        CompiledTeal @clearStateProgram;
        
        /// <summary>
        /// [apid] ID of the application being configured or empty if creating.        
        /// </summary>
        [AlgoApiField("application-id")]
        public ulong ApplicationId
        {
            get => this.@applicationId;
            set => this.@applicationId = value;
        }

        /// <summary>
        /// [apap] Logic executed for every application transaction, except when on-completion is set to &quot;clear&quot;. It can read and write global state for the application, as well as account-specific local state. Approval programs may reject the transaction.        
        /// </summary>
        [AlgoApiField("approval-program")]
        public CompiledTeal ApprovalProgram
        {
            get => this.@approvalProgram;
            set => this.@approvalProgram = value;
        }

        /// <summary>
        /// [apfa] Lists the applications in addition to the application-id whose global states may be accessed by this application's approval-program and clear-state-program. The access is read-only.        
        /// </summary>
        [AlgoApiField("foreign-apps")]
        public ulong[] ForeignApps
        {
            get => this.@foreignApps;
            set => this.@foreignApps = value;
        }

        /// <summary>
        /// [apaa] transaction specific arguments accessed from the application's approval-program and clear-state-program.        
        /// </summary>
        [AlgoApiField("application-args")]
        public string[] ApplicationArgs
        {
            get => this.@applicationArgs;
            set => this.@applicationArgs = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("on-completion")]
        public OnCompletion OnCompletion
        {
            get => this.@onCompletion;
            set => this.@onCompletion = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("global-state-schema")]
        public StateSchema GlobalStateSchema
        {
            get => this.@globalStateSchema;
            set => this.@globalStateSchema = value;
        }

        /// <summary>
        /// [epp] specifies the additional app program len requested in pages.        
        /// </summary>
        [AlgoApiField("extra-program-pages")]
        public ulong ExtraProgramPages
        {
            get => this.@extraProgramPages;
            set => this.@extraProgramPages = value;
        }

        /// <summary>
        /// [apas] lists the assets whose parameters may be accessed by this application's ApprovalProgram and ClearStateProgram. The access is read-only.        
        /// </summary>
        [AlgoApiField("foreign-assets")]
        public ulong[] ForeignAssets
        {
            get => this.@foreignAssets;
            set => this.@foreignAssets = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("local-state-schema")]
        public StateSchema LocalStateSchema
        {
            get => this.@localStateSchema;
            set => this.@localStateSchema = value;
        }

        /// <summary>
        /// [apat] List of accounts in addition to the sender that may be accessed from the application's approval-program and clear-state-program.        
        /// </summary>
        [AlgoApiField("accounts")]
        public Address[] Accounts
        {
            get => this.@accounts;
            set => this.@accounts = value;
        }

        /// <summary>
        /// [apsu] Logic executed for application transactions with on-completion set to &quot;clear&quot;. It can read and write global state for the application, as well as account-specific local state. Clear state programs cannot reject the transaction.        
        /// </summary>
        [AlgoApiField("clear-state-program")]
        public CompiledTeal ClearStateProgram
        {
            get => this.@clearStateProgram;
            set => this.@clearStateProgram = value;
        }

        public bool Equals(TransactionApplication other)
        {
            return 
                ApplicationId.Equals(other.ApplicationId) &&
                ApprovalProgram.Equals(other.ApprovalProgram) &&
                ArrayComparer.Equals(ForeignApps, other.ForeignApps) &&
                ArrayComparer.Equals(ApplicationArgs, other.ApplicationArgs) &&
                OnCompletion.Equals(other.OnCompletion) &&
                GlobalStateSchema.Equals(other.GlobalStateSchema) &&
                ExtraProgramPages.Equals(other.ExtraProgramPages) &&
                ArrayComparer.Equals(ForeignAssets, other.ForeignAssets) &&
                LocalStateSchema.Equals(other.LocalStateSchema) &&
                ArrayComparer.Equals(Accounts, other.Accounts) &&
                ClearStateProgram.Equals(other.ClearStateProgram)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationStateSchema
        : IEquatable<ApplicationStateSchema>
    {
        [SerializeField, Tooltip(@"[nbs] num of byte slices.")]
        ulong @numByteSlice;
        
        [SerializeField, Tooltip(@"[nui] num of uints.")]
        ulong @numUint;
        
        /// <summary>
        /// [nbs] num of byte slices.        
        /// </summary>
        [AlgoApiField("num-byte-slice")]
        public ulong NumByteSlice
        {
            get => this.@numByteSlice;
            set => this.@numByteSlice = value;
        }

        /// <summary>
        /// [nui] num of uints.        
        /// </summary>
        [AlgoApiField("num-uint")]
        public ulong NumUint
        {
            get => this.@numUint;
            set => this.@numUint = value;
        }

        public bool Equals(ApplicationStateSchema other)
        {
            return 
                NumByteSlice.Equals(other.NumByteSlice) &&
                NumUint.Equals(other.NumUint)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionAssetConfig
        : IEquatable<TransactionAssetConfig>
    {
        [SerializeField, Tooltip(@"[xaid] ID of the asset being configured or empty if creating.")]
        ulong @assetId;
        
        [SerializeField, Tooltip(@"")]
        AssetParams @params;
        
        /// <summary>
        /// [xaid] ID of the asset being configured or empty if creating.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public ulong AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("params")]
        public AssetParams Params
        {
            get => this.@params;
            set => this.@params = value;
        }

        public bool Equals(TransactionAssetConfig other)
        {
            return 
                AssetId.Equals(other.AssetId) &&
                Params.Equals(other.Params)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionPayment
        : IEquatable<TransactionPayment>
    {
        [SerializeField, Tooltip(@"[amt] number of MicroAlgos intended to be transferred.")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"Number of MicroAlgos that were sent to the close-remainder-to address when closing the sender account.")]
        ulong @closeAmount;
        
        [SerializeField, Tooltip(@"[close] when set, indicates that the sending account should be closed and all remaining funds be transferred to this address.")]
        string @closeRemainderTo;
        
        [SerializeField, Tooltip(@"[rcv] receiver's address.")]
        string @receiver;
        
        /// <summary>
        /// [amt] number of MicroAlgos intended to be transferred.        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// Number of MicroAlgos that were sent to the close-remainder-to address when closing the sender account.        
        /// </summary>
        [AlgoApiField("close-amount")]
        public ulong CloseAmount
        {
            get => this.@closeAmount;
            set => this.@closeAmount = value;
        }

        /// <summary>
        /// [close] when set, indicates that the sending account should be closed and all remaining funds be transferred to this address.        
        /// </summary>
        [AlgoApiField("close-remainder-to")]
        public string CloseRemainderTo
        {
            get => this.@closeRemainderTo;
            set => this.@closeRemainderTo = value;
        }

        /// <summary>
        /// [rcv] receiver's address.        
        /// </summary>
        [AlgoApiField("receiver")]
        public string Receiver
        {
            get => this.@receiver;
            set => this.@receiver = value;
        }

        public bool Equals(TransactionPayment other)
        {
            return 
                Amount.Equals(other.Amount) &&
                CloseAmount.Equals(other.CloseAmount) &&
                StringComparer.Equals(CloseRemainderTo, other.CloseRemainderTo) &&
                StringComparer.Equals(Receiver, other.Receiver)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct MiniAssetHolding
        : IEquatable<MiniAssetHolding>
    {
        [SerializeField, Tooltip(@"")]
        string @address;
        
        [SerializeField, Tooltip(@"")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"Whether or not this asset holding is currently deleted from its account.")]
        bool @deleted;
        
        [SerializeField, Tooltip(@"")]
        bool @isFrozen;
        
        [SerializeField, Tooltip(@"Round during which the account opted into the asset.")]
        ulong @optedInAtRound;
        
        [SerializeField, Tooltip(@"Round during which the account opted out of the asset.")]
        ulong @optedOutAtRound;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// Whether or not this asset holding is currently deleted from its account.        
        /// </summary>
        [AlgoApiField("deleted")]
        public bool Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("is-frozen")]
        public bool IsFrozen
        {
            get => this.@isFrozen;
            set => this.@isFrozen = value;
        }

        /// <summary>
        /// Round during which the account opted into the asset.        
        /// </summary>
        [AlgoApiField("opted-in-at-round")]
        public ulong OptedInAtRound
        {
            get => this.@optedInAtRound;
            set => this.@optedInAtRound = value;
        }

        /// <summary>
        /// Round during which the account opted out of the asset.        
        /// </summary>
        [AlgoApiField("opted-out-at-round")]
        public ulong OptedOutAtRound
        {
            get => this.@optedOutAtRound;
            set => this.@optedOutAtRound = value;
        }

        public bool Equals(MiniAssetHolding other)
        {
            return 
                StringComparer.Equals(Address, other.Address) &&
                Amount.Equals(other.Amount) &&
                Deleted.Equals(other.Deleted) &&
                IsFrozen.Equals(other.IsFrozen) &&
                OptedInAtRound.Equals(other.OptedInAtRound) &&
                OptedOutAtRound.Equals(other.OptedOutAtRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLogData
        : IEquatable<ApplicationLogData>
    {
        [SerializeField, Tooltip(@"[lg] Logs for the application being executed by the transaction.")]
        string[] @logs;
        
        [SerializeField, Tooltip(@"Transaction ID")]
        string @txid;
        
        /// <summary>
        /// [lg] Logs for the application being executed by the transaction.        
        /// </summary>
        [AlgoApiField("logs")]
        public string[] Logs
        {
            get => this.@logs;
            set => this.@logs = value;
        }

        /// <summary>
        /// Transaction ID        
        /// </summary>
        [AlgoApiField("txid")]
        public string Txid
        {
            get => this.@txid;
            set => this.@txid = value;
        }

        public bool Equals(ApplicationLogData other)
        {
            return 
                ArrayComparer.Equals(Logs, other.Logs) &&
                StringComparer.Equals(Txid, other.Txid)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionAssetFreeze
        : IEquatable<TransactionAssetFreeze>
    {
        [SerializeField, Tooltip(@"[fadd] Address of the account whose asset is being frozen or thawed.")]
        string @address;
        
        [SerializeField, Tooltip(@"[faid] ID of the asset being frozen or thawed.")]
        ulong @assetId;
        
        [SerializeField, Tooltip(@"[afrz] The new freeze status.")]
        bool @newFreezeStatus;
        
        /// <summary>
        /// [fadd] Address of the account whose asset is being frozen or thawed.        
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        /// [faid] ID of the asset being frozen or thawed.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public ulong AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        /// [afrz] The new freeze status.        
        /// </summary>
        [AlgoApiField("new-freeze-status")]
        public bool NewFreezeStatus
        {
            get => this.@newFreezeStatus;
            set => this.@newFreezeStatus = value;
        }

        public bool Equals(TransactionAssetFreeze other)
        {
            return 
                StringComparer.Equals(Address, other.Address) &&
                AssetId.Equals(other.AssetId) &&
                NewFreezeStatus.Equals(other.NewFreezeStatus)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionKeyreg
        : IEquatable<TransactionKeyreg>
    {
        [SerializeField, Tooltip(@"[nonpart] Mark the account as participating or non-participating.")]
        bool @nonParticipation;
        
        [SerializeField, Tooltip(@"[selkey] Public key used with the Verified Random Function (VRF) result during committee selection.")]
        string @selectionParticipationKey;
        
        [SerializeField, Tooltip(@"[sprfkey] State proof key used in key registration transactions.")]
        string @stateProofKey;
        
        [SerializeField, Tooltip(@"[votefst] First round this participation key is valid.")]
        ulong @voteFirstValid;
        
        [SerializeField, Tooltip(@"[votekd] Number of subkeys in each batch of participation keys.")]
        ulong @voteKeyDilution;
        
        [SerializeField, Tooltip(@"[votelst] Last round this participation key is valid.")]
        ulong @voteLastValid;
        
        [SerializeField, Tooltip(@"[votekey] Participation public key used in key registration transactions.")]
        string @voteParticipationKey;
        
        /// <summary>
        /// [nonpart] Mark the account as participating or non-participating.        
        /// </summary>
        [AlgoApiField("non-participation")]
        public bool NonParticipation
        {
            get => this.@nonParticipation;
            set => this.@nonParticipation = value;
        }

        /// <summary>
        /// [selkey] Public key used with the Verified Random Function (VRF) result during committee selection.        
        /// </summary>
        [AlgoApiField("selection-participation-key")]
        public string SelectionParticipationKey
        {
            get => this.@selectionParticipationKey;
            set => this.@selectionParticipationKey = value;
        }

        /// <summary>
        /// [sprfkey] State proof key used in key registration transactions.        
        /// </summary>
        [AlgoApiField("state-proof-key")]
        public string StateProofKey
        {
            get => this.@stateProofKey;
            set => this.@stateProofKey = value;
        }

        /// <summary>
        /// [votefst] First round this participation key is valid.        
        /// </summary>
        [AlgoApiField("vote-first-valid")]
        public ulong VoteFirstValid
        {
            get => this.@voteFirstValid;
            set => this.@voteFirstValid = value;
        }

        /// <summary>
        /// [votekd] Number of subkeys in each batch of participation keys.        
        /// </summary>
        [AlgoApiField("vote-key-dilution")]
        public ulong VoteKeyDilution
        {
            get => this.@voteKeyDilution;
            set => this.@voteKeyDilution = value;
        }

        /// <summary>
        /// [votelst] Last round this participation key is valid.        
        /// </summary>
        [AlgoApiField("vote-last-valid")]
        public ulong VoteLastValid
        {
            get => this.@voteLastValid;
            set => this.@voteLastValid = value;
        }

        /// <summary>
        /// [votekey] Participation public key used in key registration transactions.        
        /// </summary>
        [AlgoApiField("vote-participation-key")]
        public string VoteParticipationKey
        {
            get => this.@voteParticipationKey;
            set => this.@voteParticipationKey = value;
        }

        public bool Equals(TransactionKeyreg other)
        {
            return 
                NonParticipation.Equals(other.NonParticipation) &&
                StringComparer.Equals(SelectionParticipationKey, other.SelectionParticipationKey) &&
                StringComparer.Equals(StateProofKey, other.StateProofKey) &&
                VoteFirstValid.Equals(other.VoteFirstValid) &&
                VoteKeyDilution.Equals(other.VoteKeyDilution) &&
                VoteLastValid.Equals(other.VoteLastValid) &&
                StringComparer.Equals(VoteParticipationKey, other.VoteParticipationKey)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignature
        : IEquatable<TransactionSignature>
    {
        [SerializeField, Tooltip(@"")]
        TransactionSignatureLogicsig @logicsig;
        
        [SerializeField, Tooltip(@"")]
        TransactionSignatureMultisig @multisig;
        
        [SerializeField, Tooltip(@"[sig] Standard ed25519 signature.")]
        string @sig;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("logicsig")]
        public TransactionSignatureLogicsig Logicsig
        {
            get => this.@logicsig;
            set => this.@logicsig = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("multisig")]
        public TransactionSignatureMultisig Multisig
        {
            get => this.@multisig;
            set => this.@multisig = value;
        }

        /// <summary>
        /// [sig] Standard ed25519 signature.        
        /// </summary>
        [AlgoApiField("sig")]
        public string Sig
        {
            get => this.@sig;
            set => this.@sig = value;
        }

        public bool Equals(TransactionSignature other)
        {
            return 
                Logicsig.Equals(other.Logicsig) &&
                Multisig.Equals(other.Multisig) &&
                StringComparer.Equals(Sig, other.Sig)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Asset
        : IEquatable<Asset>
    {
        [SerializeField, Tooltip(@"Round during which this asset was created.")]
        ulong @createdAtRound;
        
        [SerializeField, Tooltip(@"Whether or not this asset is currently deleted.")]
        bool @deleted;
        
        [SerializeField, Tooltip(@"Round during which this asset was destroyed.")]
        ulong @destroyedAtRound;
        
        [SerializeField, Tooltip(@"unique asset identifier")]
        ulong @index;
        
        [SerializeField, Tooltip(@"")]
        AssetParams @params;
        
        /// <summary>
        /// Round during which this asset was created.        
        /// </summary>
        [AlgoApiField("created-at-round")]
        public ulong CreatedAtRound
        {
            get => this.@createdAtRound;
            set => this.@createdAtRound = value;
        }

        /// <summary>
        /// Whether or not this asset is currently deleted.        
        /// </summary>
        [AlgoApiField("deleted")]
        public bool Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// Round during which this asset was destroyed.        
        /// </summary>
        [AlgoApiField("destroyed-at-round")]
        public ulong DestroyedAtRound
        {
            get => this.@destroyedAtRound;
            set => this.@destroyedAtRound = value;
        }

        /// <summary>
        /// unique asset identifier        
        /// </summary>
        [AlgoApiField("index")]
        public ulong Index
        {
            get => this.@index;
            set => this.@index = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("params")]
        public AssetParams Params
        {
            get => this.@params;
            set => this.@params = value;
        }

        public bool Equals(Asset other)
        {
            return 
                CreatedAtRound.Equals(other.CreatedAtRound) &&
                Deleted.Equals(other.Deleted) &&
                DestroyedAtRound.Equals(other.DestroyedAtRound) &&
                Index.Equals(other.Index) &&
                Params.Equals(other.Params)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TealKeyValue
        : IEquatable<TealKeyValue>
    {
        [SerializeField, Tooltip(@"")]
        string @key;
        
        [SerializeField, Tooltip(@"")]
        TealValue @value;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("key")]
        public string Key
        {
            get => this.@key;
            set => this.@key = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("value")]
        public TealValue Value
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(TealKeyValue other)
        {
            return 
                StringComparer.Equals(Key, other.Key) &&
                Value.Equals(other.Value)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct HealthCheck
        : IEquatable<HealthCheck>
    {
        [SerializeField, Tooltip(@"")]
        AlgoApiObject @data;
        
        [SerializeField, Tooltip(@"")]
        bool @dbAvailable;
        
        [SerializeField, Tooltip(@"")]
        string[] @errors;
        
        [SerializeField, Tooltip(@"")]
        bool @isMigrating;
        
        [SerializeField, Tooltip(@"")]
        string @message;
        
        [SerializeField, Tooltip(@"")]
        ulong @round;
        
        [SerializeField, Tooltip(@"Current version.")]
        string @version;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("data")]
        public AlgoApiObject Data
        {
            get => this.@data;
            set => this.@data = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("db-available")]
        public bool DbAvailable
        {
            get => this.@dbAvailable;
            set => this.@dbAvailable = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("errors")]
        public string[] Errors
        {
            get => this.@errors;
            set => this.@errors = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("is-migrating")]
        public bool IsMigrating
        {
            get => this.@isMigrating;
            set => this.@isMigrating = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("message")]
        public string Message
        {
            get => this.@message;
            set => this.@message = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("round")]
        public ulong Round
        {
            get => this.@round;
            set => this.@round = value;
        }

        /// <summary>
        /// Current version.        
        /// </summary>
        [AlgoApiField("version")]
        public string Version
        {
            get => this.@version;
            set => this.@version = value;
        }

        public bool Equals(HealthCheck other)
        {
            return 
                Data.Equals(other.Data) &&
                DbAvailable.Equals(other.DbAvailable) &&
                ArrayComparer.Equals(Errors, other.Errors) &&
                IsMigrating.Equals(other.IsMigrating) &&
                StringComparer.Equals(Message, other.Message) &&
                Round.Equals(other.Round) &&
                StringComparer.Equals(Version, other.Version)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct EvalDeltaKeyValue
        : IEquatable<EvalDeltaKeyValue>
    {
        [SerializeField, Tooltip(@"")]
        string @key;
        
        [SerializeField, Tooltip(@"")]
        EvalDelta @value;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("key")]
        public string Key
        {
            get => this.@key;
            set => this.@key = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("value")]
        public EvalDelta Value
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(EvalDeltaKeyValue other)
        {
            return 
                StringComparer.Equals(Key, other.Key) &&
                Value.Equals(other.Value)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetHolding
        : IEquatable<AssetHolding>
    {
        [SerializeField, Tooltip(@"[a] number of units held.")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"Asset ID of the holding.")]
        ulong @assetId;
        
        [SerializeField, Tooltip(@"Whether or not the asset holding is currently deleted from its account.")]
        bool @deleted;
        
        [SerializeField, Tooltip(@"[f] whether or not the holding is frozen.")]
        bool @isFrozen;
        
        [SerializeField, Tooltip(@"Round during which the account opted into this asset holding.")]
        ulong @optedInAtRound;
        
        [SerializeField, Tooltip(@"Round during which the account opted out of this asset holding.")]
        ulong @optedOutAtRound;
        
        /// <summary>
        /// [a] number of units held.        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// Asset ID of the holding.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public ulong AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        /// Whether or not the asset holding is currently deleted from its account.        
        /// </summary>
        [AlgoApiField("deleted")]
        public bool Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// [f] whether or not the holding is frozen.        
        /// </summary>
        [AlgoApiField("is-frozen")]
        public bool IsFrozen
        {
            get => this.@isFrozen;
            set => this.@isFrozen = value;
        }

        /// <summary>
        /// Round during which the account opted into this asset holding.        
        /// </summary>
        [AlgoApiField("opted-in-at-round")]
        public ulong OptedInAtRound
        {
            get => this.@optedInAtRound;
            set => this.@optedInAtRound = value;
        }

        /// <summary>
        /// Round during which the account opted out of this asset holding.        
        /// </summary>
        [AlgoApiField("opted-out-at-round")]
        public ulong OptedOutAtRound
        {
            get => this.@optedOutAtRound;
            set => this.@optedOutAtRound = value;
        }

        public bool Equals(AssetHolding other)
        {
            return 
                Amount.Equals(other.Amount) &&
                AssetId.Equals(other.AssetId) &&
                Deleted.Equals(other.Deleted) &&
                IsFrozen.Equals(other.IsFrozen) &&
                OptedInAtRound.Equals(other.OptedInAtRound) &&
                OptedOutAtRound.Equals(other.OptedOutAtRound)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Account
        : IEquatable<Account>
    {
        [SerializeField, Tooltip(@"[algo] total number of MicroAlgos in the account")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"Whether or not this account is currently closed.")]
        bool @deleted;
        
        [SerializeField, Tooltip(@"the account public key")]
        string @address;
        
        [SerializeField, Tooltip(@"[ern] total rewards of MicroAlgos the account has received, including pending rewards.")]
        ulong @rewards;
        
        [SerializeField, Tooltip(@"Round during which this account was most recently closed.")]
        ulong @closedAtRound;
        
        [SerializeField, Tooltip(@"specifies the amount of MicroAlgos in the account, without the pending rewards.")]
        ulong @amountWithoutPendingRewards;
        
        [SerializeField, Tooltip(@"[teap] the sum of all extra application program pages for this account.")]
        ulong @appsTotalExtraPages;
        
        [SerializeField, Tooltip(@"The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.")]
        ulong @totalAssetsOptedIn;
        
        [SerializeField, Tooltip(@"[asset] assets held by this account.

Note the raw object uses `map[int] -&gt; AssetHolding` for this type.")]
        AssetHolding[] @assets;
        
        [SerializeField, Tooltip(@"Round during which this account first appeared in a transaction.")]
        ulong @createdAtRound;
        
        [SerializeField, Tooltip(@"")]
        AccountParticipation @participation;
        
        [SerializeField, Tooltip(@"")]
        ApplicationStateSchema @appsTotalSchema;
        
        [SerializeField, Tooltip(@"The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.")]
        ulong @totalAppsOptedIn;
        
        [SerializeField, Tooltip(@"The round for which this information is relevant.")]
        ulong @round;
        
        [SerializeField, Tooltip(@"amount of MicroAlgos of pending rewards in this account.")]
        ulong @pendingRewards;
        
        [SerializeField, Tooltip(@"[appp] parameters of applications created by this account including app global data.

Note: the raw account uses `map[int] -&gt; AppParams` for this type.")]
        Application[] @createdApps;
        
        [SerializeField, Tooltip(@"[onl] delegation status of the account's MicroAlgos
* Offline - indicates that the associated account is delegated.
*  Online  - indicates that the associated account used as part of the delegation pool.
*   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.")]
        string @status;
        
        [SerializeField, Tooltip(@"Indicates what type of signature is used by this account, must be one of:
* sig
* msig
* lsig
* or null if unknown")]
        SignatureType @sigType;
        
        [SerializeField, Tooltip(@"[spend] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.")]
        Address @authAddr;
        
        [SerializeField, Tooltip(@"The count of all assets (AssetParams objects) created by this account.")]
        ulong @totalCreatedAssets;
        
        [SerializeField, Tooltip(@"[ebase] used as part of the rewards computation. Only applicable to accounts which are participating.")]
        ulong @rewardBase;
        
        [SerializeField, Tooltip(@"[apar] parameters of assets created by this account.

Note: the raw account uses `map[int] -&gt; Asset` for this type.")]
        Asset[] @createdAssets;
        
        [SerializeField, Tooltip(@"[appl] applications local data stored in this account.

Note the raw object uses `map[int] -&gt; AppLocalState` for this type.")]
        ApplicationLocalState[] @appsLocalState;
        
        [SerializeField, Tooltip(@"The count of all apps (AppParams objects) created by this account.")]
        ulong @totalCreatedApps;
        
        /// <summary>
        /// [algo] total number of MicroAlgos in the account        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// Whether or not this account is currently closed.        
        /// </summary>
        [AlgoApiField("deleted")]
        public bool Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// the account public key        
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        /// [ern] total rewards of MicroAlgos the account has received, including pending rewards.        
        /// </summary>
        [AlgoApiField("rewards")]
        public ulong Rewards
        {
            get => this.@rewards;
            set => this.@rewards = value;
        }

        /// <summary>
        /// Round during which this account was most recently closed.        
        /// </summary>
        [AlgoApiField("closed-at-round")]
        public ulong ClosedAtRound
        {
            get => this.@closedAtRound;
            set => this.@closedAtRound = value;
        }

        /// <summary>
        /// specifies the amount of MicroAlgos in the account, without the pending rewards.        
        /// </summary>
        [AlgoApiField("amount-without-pending-rewards")]
        public ulong AmountWithoutPendingRewards
        {
            get => this.@amountWithoutPendingRewards;
            set => this.@amountWithoutPendingRewards = value;
        }

        /// <summary>
        /// [teap] the sum of all extra application program pages for this account.        
        /// </summary>
        [AlgoApiField("apps-total-extra-pages")]
        public ulong AppsTotalExtraPages
        {
            get => this.@appsTotalExtraPages;
            set => this.@appsTotalExtraPages = value;
        }

        /// <summary>
        /// The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.        
        /// </summary>
        [AlgoApiField("total-assets-opted-in")]
        public ulong TotalAssetsOptedIn
        {
            get => this.@totalAssetsOptedIn;
            set => this.@totalAssetsOptedIn = value;
        }

        /// <summary>
        /// [asset] assets held by this account.
        /// 
        /// Note the raw object uses `map[int] -&gt; AssetHolding` for this type.        
        /// </summary>
        [AlgoApiField("assets")]
        public AssetHolding[] Assets
        {
            get => this.@assets;
            set => this.@assets = value;
        }

        /// <summary>
        /// Round during which this account first appeared in a transaction.        
        /// </summary>
        [AlgoApiField("created-at-round")]
        public ulong CreatedAtRound
        {
            get => this.@createdAtRound;
            set => this.@createdAtRound = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("participation")]
        public AccountParticipation Participation
        {
            get => this.@participation;
            set => this.@participation = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("apps-total-schema")]
        public ApplicationStateSchema AppsTotalSchema
        {
            get => this.@appsTotalSchema;
            set => this.@appsTotalSchema = value;
        }

        /// <summary>
        /// The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.        
        /// </summary>
        [AlgoApiField("total-apps-opted-in")]
        public ulong TotalAppsOptedIn
        {
            get => this.@totalAppsOptedIn;
            set => this.@totalAppsOptedIn = value;
        }

        /// <summary>
        /// The round for which this information is relevant.        
        /// </summary>
        [AlgoApiField("round")]
        public ulong Round
        {
            get => this.@round;
            set => this.@round = value;
        }

        /// <summary>
        /// amount of MicroAlgos of pending rewards in this account.        
        /// </summary>
        [AlgoApiField("pending-rewards")]
        public ulong PendingRewards
        {
            get => this.@pendingRewards;
            set => this.@pendingRewards = value;
        }

        /// <summary>
        /// [appp] parameters of applications created by this account including app global data.
        /// 
        /// Note: the raw account uses `map[int] -&gt; AppParams` for this type.        
        /// </summary>
        [AlgoApiField("created-apps")]
        public Application[] CreatedApps
        {
            get => this.@createdApps;
            set => this.@createdApps = value;
        }

        /// <summary>
        /// [onl] delegation status of the account's MicroAlgos
        /// * Offline - indicates that the associated account is delegated.
        /// *  Online  - indicates that the associated account used as part of the delegation pool.
        /// *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.        
        /// </summary>
        [AlgoApiField("status")]
        public string Status
        {
            get => this.@status;
            set => this.@status = value;
        }

        /// <summary>
        /// Indicates what type of signature is used by this account, must be one of:
        /// * sig
        /// * msig
        /// * lsig
        /// * or null if unknown        
        /// </summary>
        [AlgoApiField("sig-type")]
        public SignatureType SigType
        {
            get => this.@sigType;
            set => this.@sigType = value;
        }

        /// <summary>
        /// [spend] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.        
        /// </summary>
        [AlgoApiField("auth-addr")]
        public Address AuthAddr
        {
            get => this.@authAddr;
            set => this.@authAddr = value;
        }

        /// <summary>
        /// The count of all assets (AssetParams objects) created by this account.        
        /// </summary>
        [AlgoApiField("total-created-assets")]
        public ulong TotalCreatedAssets
        {
            get => this.@totalCreatedAssets;
            set => this.@totalCreatedAssets = value;
        }

        /// <summary>
        /// [ebase] used as part of the rewards computation. Only applicable to accounts which are participating.        
        /// </summary>
        [AlgoApiField("reward-base")]
        public ulong RewardBase
        {
            get => this.@rewardBase;
            set => this.@rewardBase = value;
        }

        /// <summary>
        /// [apar] parameters of assets created by this account.
        /// 
        /// Note: the raw account uses `map[int] -&gt; Asset` for this type.        
        /// </summary>
        [AlgoApiField("created-assets")]
        public Asset[] CreatedAssets
        {
            get => this.@createdAssets;
            set => this.@createdAssets = value;
        }

        /// <summary>
        /// [appl] applications local data stored in this account.
        /// 
        /// Note the raw object uses `map[int] -&gt; AppLocalState` for this type.        
        /// </summary>
        [AlgoApiField("apps-local-state")]
        public ApplicationLocalState[] AppsLocalState
        {
            get => this.@appsLocalState;
            set => this.@appsLocalState = value;
        }

        /// <summary>
        /// The count of all apps (AppParams objects) created by this account.        
        /// </summary>
        [AlgoApiField("total-created-apps")]
        public ulong TotalCreatedApps
        {
            get => this.@totalCreatedApps;
            set => this.@totalCreatedApps = value;
        }

        public bool Equals(Account other)
        {
            return 
                Amount.Equals(other.Amount) &&
                Deleted.Equals(other.Deleted) &&
                StringComparer.Equals(Address, other.Address) &&
                Rewards.Equals(other.Rewards) &&
                ClosedAtRound.Equals(other.ClosedAtRound) &&
                AmountWithoutPendingRewards.Equals(other.AmountWithoutPendingRewards) &&
                AppsTotalExtraPages.Equals(other.AppsTotalExtraPages) &&
                TotalAssetsOptedIn.Equals(other.TotalAssetsOptedIn) &&
                ArrayComparer.Equals(Assets, other.Assets) &&
                CreatedAtRound.Equals(other.CreatedAtRound) &&
                Participation.Equals(other.Participation) &&
                AppsTotalSchema.Equals(other.AppsTotalSchema) &&
                TotalAppsOptedIn.Equals(other.TotalAppsOptedIn) &&
                Round.Equals(other.Round) &&
                PendingRewards.Equals(other.PendingRewards) &&
                ArrayComparer.Equals(CreatedApps, other.CreatedApps) &&
                StringComparer.Equals(Status, other.Status) &&
                SigType.Equals(other.SigType) &&
                AuthAddr.Equals(other.AuthAddr) &&
                TotalCreatedAssets.Equals(other.TotalCreatedAssets) &&
                RewardBase.Equals(other.RewardBase) &&
                ArrayComparer.Equals(CreatedAssets, other.CreatedAssets) &&
                ArrayComparer.Equals(AppsLocalState, other.AppsLocalState) &&
                TotalCreatedApps.Equals(other.TotalCreatedApps)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BlockRewards
        : IEquatable<BlockRewards>
    {
        [SerializeField, Tooltip(@"[fees] accepts transaction fees, it can only spend to the incentive pool.")]
        string @feeSink;
        
        [SerializeField, Tooltip(@"[rwcalr] number of leftover MicroAlgos after the distribution of rewards-rate MicroAlgos for every reward unit in the next round.")]
        ulong @rewardsCalculationRound;
        
        [SerializeField, Tooltip(@"[earn] How many rewards, in MicroAlgos, have been distributed to each RewardUnit of MicroAlgos since genesis.")]
        ulong @rewardsLevel;
        
        [SerializeField, Tooltip(@"[rwd] accepts periodic injections from the fee-sink and continually redistributes them as rewards.")]
        string @rewardsPool;
        
        [SerializeField, Tooltip(@"[rate] Number of new MicroAlgos added to the participation stake from rewards at the next round.")]
        ulong @rewardsRate;
        
        [SerializeField, Tooltip(@"[frac] Number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.")]
        ulong @rewardsResidue;
        
        /// <summary>
        /// [fees] accepts transaction fees, it can only spend to the incentive pool.        
        /// </summary>
        [AlgoApiField("fee-sink")]
        public string FeeSink
        {
            get => this.@feeSink;
            set => this.@feeSink = value;
        }

        /// <summary>
        /// [rwcalr] number of leftover MicroAlgos after the distribution of rewards-rate MicroAlgos for every reward unit in the next round.        
        /// </summary>
        [AlgoApiField("rewards-calculation-round")]
        public ulong RewardsCalculationRound
        {
            get => this.@rewardsCalculationRound;
            set => this.@rewardsCalculationRound = value;
        }

        /// <summary>
        /// [earn] How many rewards, in MicroAlgos, have been distributed to each RewardUnit of MicroAlgos since genesis.        
        /// </summary>
        [AlgoApiField("rewards-level")]
        public ulong RewardsLevel
        {
            get => this.@rewardsLevel;
            set => this.@rewardsLevel = value;
        }

        /// <summary>
        /// [rwd] accepts periodic injections from the fee-sink and continually redistributes them as rewards.        
        /// </summary>
        [AlgoApiField("rewards-pool")]
        public string RewardsPool
        {
            get => this.@rewardsPool;
            set => this.@rewardsPool = value;
        }

        /// <summary>
        /// [rate] Number of new MicroAlgos added to the participation stake from rewards at the next round.        
        /// </summary>
        [AlgoApiField("rewards-rate")]
        public ulong RewardsRate
        {
            get => this.@rewardsRate;
            set => this.@rewardsRate = value;
        }

        /// <summary>
        /// [frac] Number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.        
        /// </summary>
        [AlgoApiField("rewards-residue")]
        public ulong RewardsResidue
        {
            get => this.@rewardsResidue;
            set => this.@rewardsResidue = value;
        }

        public bool Equals(BlockRewards other)
        {
            return 
                StringComparer.Equals(FeeSink, other.FeeSink) &&
                RewardsCalculationRound.Equals(other.RewardsCalculationRound) &&
                RewardsLevel.Equals(other.RewardsLevel) &&
                StringComparer.Equals(RewardsPool, other.RewardsPool) &&
                RewardsRate.Equals(other.RewardsRate) &&
                RewardsResidue.Equals(other.RewardsResidue)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountStateDelta
        : IEquatable<AccountStateDelta>
    {
        [SerializeField, Tooltip(@"")]
        string @address;
        
        [SerializeField, Tooltip(@"")]
        StateDelta @delta;
        
        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("address")]
        public string Address
        {
            get => this.@address;
            set => this.@address = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("delta")]
        public StateDelta Delta
        {
            get => this.@delta;
            set => this.@delta = value;
        }

        public bool Equals(AccountStateDelta other)
        {
            return 
                StringComparer.Equals(Address, other.Address) &&
                Delta.Equals(other.Delta)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BlockUpgradeVote
        : IEquatable<BlockUpgradeVote>
    {
        [SerializeField, Tooltip(@"[upgradeyes] Indicates a yes vote for the current proposal.")]
        bool @upgradeApprove;
        
        [SerializeField, Tooltip(@"[upgradedelay] Indicates the time between acceptance and execution.")]
        ulong @upgradeDelay;
        
        [SerializeField, Tooltip(@"[upgradeprop] Indicates a proposed upgrade.")]
        string @upgradePropose;
        
        /// <summary>
        /// [upgradeyes] Indicates a yes vote for the current proposal.        
        /// </summary>
        [AlgoApiField("upgrade-approve")]
        public bool UpgradeApprove
        {
            get => this.@upgradeApprove;
            set => this.@upgradeApprove = value;
        }

        /// <summary>
        /// [upgradedelay] Indicates the time between acceptance and execution.        
        /// </summary>
        [AlgoApiField("upgrade-delay")]
        public ulong UpgradeDelay
        {
            get => this.@upgradeDelay;
            set => this.@upgradeDelay = value;
        }

        /// <summary>
        /// [upgradeprop] Indicates a proposed upgrade.        
        /// </summary>
        [AlgoApiField("upgrade-propose")]
        public string UpgradePropose
        {
            get => this.@upgradePropose;
            set => this.@upgradePropose = value;
        }

        public bool Equals(BlockUpgradeVote other)
        {
            return 
                UpgradeApprove.Equals(other.UpgradeApprove) &&
                UpgradeDelay.Equals(other.UpgradeDelay) &&
                StringComparer.Equals(UpgradePropose, other.UpgradePropose)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Application
        : IEquatable<Application>
    {
        [SerializeField, Tooltip(@"Round when this application was created.")]
        ulong @createdAtRound;
        
        [SerializeField, Tooltip(@"Whether or not this application is currently deleted.")]
        bool @deleted;
        
        [SerializeField, Tooltip(@"Round when this application was deleted.")]
        ulong @deletedAtRound;
        
        [SerializeField, Tooltip(@"[appidx] application index.")]
        ulong @id;
        
        [SerializeField, Tooltip(@"")]
        ApplicationParams @params;
        
        /// <summary>
        /// Round when this application was created.        
        /// </summary>
        [AlgoApiField("created-at-round")]
        public ulong CreatedAtRound
        {
            get => this.@createdAtRound;
            set => this.@createdAtRound = value;
        }

        /// <summary>
        /// Whether or not this application is currently deleted.        
        /// </summary>
        [AlgoApiField("deleted")]
        public bool Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// Round when this application was deleted.        
        /// </summary>
        [AlgoApiField("deleted-at-round")]
        public ulong DeletedAtRound
        {
            get => this.@deletedAtRound;
            set => this.@deletedAtRound = value;
        }

        /// <summary>
        /// [appidx] application index.        
        /// </summary>
        [AlgoApiField("id")]
        public ulong Id
        {
            get => this.@id;
            set => this.@id = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("params")]
        public ApplicationParams Params
        {
            get => this.@params;
            set => this.@params = value;
        }

        public bool Equals(Application other)
        {
            return 
                CreatedAtRound.Equals(other.CreatedAtRound) &&
                Deleted.Equals(other.Deleted) &&
                DeletedAtRound.Equals(other.DeletedAtRound) &&
                Id.Equals(other.Id) &&
                Params.Equals(other.Params)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct StateSchema
        : IEquatable<StateSchema>
    {
        [SerializeField, Tooltip(@"Maximum number of TEAL byte slices that may be stored in the key/value store.")]
        ulong @numByteSlice;
        
        [SerializeField, Tooltip(@"Maximum number of TEAL uints that may be stored in the key/value store.")]
        ulong @numUint;
        
        /// <summary>
        /// Maximum number of TEAL byte slices that may be stored in the key/value store.        
        /// </summary>
        [AlgoApiField("num-byte-slice")]
        public ulong NumByteSlice
        {
            get => this.@numByteSlice;
            set => this.@numByteSlice = value;
        }

        /// <summary>
        /// Maximum number of TEAL uints that may be stored in the key/value store.        
        /// </summary>
        [AlgoApiField("num-uint")]
        public ulong NumUint
        {
            get => this.@numUint;
            set => this.@numUint = value;
        }

        public bool Equals(StateSchema other)
        {
            return 
                NumByteSlice.Equals(other.NumByteSlice) &&
                NumUint.Equals(other.NumUint)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct ApplicationLocalState
        : IEquatable<ApplicationLocalState>
    {
        [SerializeField, Tooltip(@"Round when account closed out of the application.")]
        ulong @closedOutAtRound;
        
        [SerializeField, Tooltip(@"Whether or not the application local state is currently deleted from its account.")]
        bool @deleted;
        
        [SerializeField, Tooltip(@"The application which this local state is for.")]
        ulong @id;
        
        [SerializeField, Tooltip(@"")]
        TealKeyValueStore @keyValue;
        
        [SerializeField, Tooltip(@"Round when the account opted into the application.")]
        ulong @optedInAtRound;
        
        [SerializeField, Tooltip(@"")]
        ApplicationStateSchema @schema;
        
        /// <summary>
        /// Round when account closed out of the application.        
        /// </summary>
        [AlgoApiField("closed-out-at-round")]
        public ulong ClosedOutAtRound
        {
            get => this.@closedOutAtRound;
            set => this.@closedOutAtRound = value;
        }

        /// <summary>
        /// Whether or not the application local state is currently deleted from its account.        
        /// </summary>
        [AlgoApiField("deleted")]
        public bool Deleted
        {
            get => this.@deleted;
            set => this.@deleted = value;
        }

        /// <summary>
        /// The application which this local state is for.        
        /// </summary>
        [AlgoApiField("id")]
        public ulong Id
        {
            get => this.@id;
            set => this.@id = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("key-value")]
        public TealKeyValueStore KeyValue
        {
            get => this.@keyValue;
            set => this.@keyValue = value;
        }

        /// <summary>
        /// Round when the account opted into the application.        
        /// </summary>
        [AlgoApiField("opted-in-at-round")]
        public ulong OptedInAtRound
        {
            get => this.@optedInAtRound;
            set => this.@optedInAtRound = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("schema")]
        public ApplicationStateSchema Schema
        {
            get => this.@schema;
            set => this.@schema = value;
        }

        public bool Equals(ApplicationLocalState other)
        {
            return 
                ClosedOutAtRound.Equals(other.ClosedOutAtRound) &&
                Deleted.Equals(other.Deleted) &&
                Id.Equals(other.Id) &&
                KeyValue.Equals(other.KeyValue) &&
                OptedInAtRound.Equals(other.OptedInAtRound) &&
                Schema.Equals(other.Schema)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionSignatureMultisigSubsignature
        : IEquatable<TransactionSignatureMultisigSubsignature>
    {
        [SerializeField, Tooltip(@"[pk]")]
        string @publicKey;
        
        [SerializeField, Tooltip(@"[s]")]
        string @signature;
        
        /// <summary>
        /// [pk]        
        /// </summary>
        [AlgoApiField("public-key")]
        public string PublicKey
        {
            get => this.@publicKey;
            set => this.@publicKey = value;
        }

        /// <summary>
        /// [s]        
        /// </summary>
        [AlgoApiField("signature")]
        public string Signature
        {
            get => this.@signature;
            set => this.@signature = value;
        }

        public bool Equals(TransactionSignatureMultisigSubsignature other)
        {
            return 
                StringComparer.Equals(PublicKey, other.PublicKey) &&
                StringComparer.Equals(Signature, other.Signature)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AccountParticipation
        : IEquatable<AccountParticipation>
    {
        [SerializeField, Tooltip(@"[sel] Selection public key (if any) currently registered for this round.")]
        string @selectionParticipationKey;
        
        [SerializeField, Tooltip(@"[stprf] Root of the state proof key (if any)")]
        string @stateProofKey;
        
        [SerializeField, Tooltip(@"[voteFst] First round for which this participation is valid.")]
        ulong @voteFirstValid;
        
        [SerializeField, Tooltip(@"[voteKD] Number of subkeys in each batch of participation keys.")]
        ulong @voteKeyDilution;
        
        [SerializeField, Tooltip(@"[voteLst] Last round for which this participation is valid.")]
        ulong @voteLastValid;
        
        [SerializeField, Tooltip(@"[vote] root participation public key (if any) currently registered for this round.")]
        string @voteParticipationKey;
        
        /// <summary>
        /// [sel] Selection public key (if any) currently registered for this round.        
        /// </summary>
        [AlgoApiField("selection-participation-key")]
        public string SelectionParticipationKey
        {
            get => this.@selectionParticipationKey;
            set => this.@selectionParticipationKey = value;
        }

        /// <summary>
        /// [stprf] Root of the state proof key (if any)        
        /// </summary>
        [AlgoApiField("state-proof-key")]
        public string StateProofKey
        {
            get => this.@stateProofKey;
            set => this.@stateProofKey = value;
        }

        /// <summary>
        /// [voteFst] First round for which this participation is valid.        
        /// </summary>
        [AlgoApiField("vote-first-valid")]
        public ulong VoteFirstValid
        {
            get => this.@voteFirstValid;
            set => this.@voteFirstValid = value;
        }

        /// <summary>
        /// [voteKD] Number of subkeys in each batch of participation keys.        
        /// </summary>
        [AlgoApiField("vote-key-dilution")]
        public ulong VoteKeyDilution
        {
            get => this.@voteKeyDilution;
            set => this.@voteKeyDilution = value;
        }

        /// <summary>
        /// [voteLst] Last round for which this participation is valid.        
        /// </summary>
        [AlgoApiField("vote-last-valid")]
        public ulong VoteLastValid
        {
            get => this.@voteLastValid;
            set => this.@voteLastValid = value;
        }

        /// <summary>
        /// [vote] root participation public key (if any) currently registered for this round.        
        /// </summary>
        [AlgoApiField("vote-participation-key")]
        public string VoteParticipationKey
        {
            get => this.@voteParticipationKey;
            set => this.@voteParticipationKey = value;
        }

        public bool Equals(AccountParticipation other)
        {
            return 
                StringComparer.Equals(SelectionParticipationKey, other.SelectionParticipationKey) &&
                StringComparer.Equals(StateProofKey, other.StateProofKey) &&
                VoteFirstValid.Equals(other.VoteFirstValid) &&
                VoteKeyDilution.Equals(other.VoteKeyDilution) &&
                VoteLastValid.Equals(other.VoteLastValid) &&
                StringComparer.Equals(VoteParticipationKey, other.VoteParticipationKey)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct TransactionAssetTransfer
        : IEquatable<TransactionAssetTransfer>
    {
        [SerializeField, Tooltip(@"[aamt] Amount of asset to transfer. A zero amount transferred to self allocates that asset in the account's Assets map.")]
        ulong @amount;
        
        [SerializeField, Tooltip(@"[xaid] ID of the asset being transferred.")]
        ulong @assetId;
        
        [SerializeField, Tooltip(@"Number of assets transfered to the close-to account as part of the transaction.")]
        ulong @closeAmount;
        
        [SerializeField, Tooltip(@"[aclose] Indicates that the asset should be removed from the account's Assets map, and specifies where the remaining asset holdings should be transferred.  It's always valid to transfer remaining asset holdings to the creator account.")]
        string @closeTo;
        
        [SerializeField, Tooltip(@"[arcv] Recipient address of the transfer.")]
        string @receiver;
        
        [SerializeField, Tooltip(@"[asnd] The effective sender during a clawback transactions. If this is not a zero value, the real transaction sender must be the Clawback address from the AssetParams.")]
        string @sender;
        
        /// <summary>
        /// [aamt] Amount of asset to transfer. A zero amount transferred to self allocates that asset in the account's Assets map.        
        /// </summary>
        [AlgoApiField("amount")]
        public ulong Amount
        {
            get => this.@amount;
            set => this.@amount = value;
        }

        /// <summary>
        /// [xaid] ID of the asset being transferred.        
        /// </summary>
        [AlgoApiField("asset-id")]
        public ulong AssetId
        {
            get => this.@assetId;
            set => this.@assetId = value;
        }

        /// <summary>
        /// Number of assets transfered to the close-to account as part of the transaction.        
        /// </summary>
        [AlgoApiField("close-amount")]
        public ulong CloseAmount
        {
            get => this.@closeAmount;
            set => this.@closeAmount = value;
        }

        /// <summary>
        /// [aclose] Indicates that the asset should be removed from the account's Assets map, and specifies where the remaining asset holdings should be transferred.  It's always valid to transfer remaining asset holdings to the creator account.        
        /// </summary>
        [AlgoApiField("close-to")]
        public string CloseTo
        {
            get => this.@closeTo;
            set => this.@closeTo = value;
        }

        /// <summary>
        /// [arcv] Recipient address of the transfer.        
        /// </summary>
        [AlgoApiField("receiver")]
        public string Receiver
        {
            get => this.@receiver;
            set => this.@receiver = value;
        }

        /// <summary>
        /// [asnd] The effective sender during a clawback transactions. If this is not a zero value, the real transaction sender must be the Clawback address from the AssetParams.        
        /// </summary>
        [AlgoApiField("sender")]
        public string Sender
        {
            get => this.@sender;
            set => this.@sender = value;
        }

        public bool Equals(TransactionAssetTransfer other)
        {
            return 
                Amount.Equals(other.Amount) &&
                AssetId.Equals(other.AssetId) &&
                CloseAmount.Equals(other.CloseAmount) &&
                StringComparer.Equals(CloseTo, other.CloseTo) &&
                StringComparer.Equals(Receiver, other.Receiver) &&
                StringComparer.Equals(Sender, other.Sender)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct Transaction
        : IEquatable<Transaction>
    {
        [SerializeField, Tooltip(@"[fee] Transaction fee.")]
        ulong @fee;
        
        [SerializeField, Tooltip(@"")]
        TransactionAssetTransfer @assetTransferTransaction;
        
        [SerializeField, Tooltip(@"[grp] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.")]
        string @group;
        
        [SerializeField, Tooltip(@"Specifies an application index (ID) if an application was created with this transaction.")]
        ulong @createdApplicationIndex;
        
        [SerializeField, Tooltip(@"[lx] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.")]
        string @lease;
        
        [SerializeField, Tooltip(@"[gh] Hash of genesis block.")]
        string @genesisHash;
        
        [SerializeField, Tooltip(@"[lg] Logs for the application being executed by this transaction.")]
        string[] @logs;
        
        [SerializeField, Tooltip(@"[rs] rewards applied to sender account.")]
        ulong @senderRewards;
        
        [SerializeField, Tooltip(@"[ca] closing amount for transaction.")]
        ulong @closingAmount;
        
        [SerializeField, Tooltip(@"")]
        TransactionSignature @signature;
        
        [SerializeField, Tooltip(@"")]
        StateDelta @globalStateDelta;
        
        [SerializeField, Tooltip(@"[type] Indicates what type of transaction this is. Different types have different fields.

Valid types, and where their fields are stored:
* [pay] payment-transaction
* [keyreg] keyreg-transaction
* [acfg] asset-config-transaction
* [axfer] asset-transfer-transaction
* [afrz] asset-freeze-transaction
* [appl] application-transaction")]
        TransactionType @txType;
        
        [SerializeField, Tooltip(@"Offset into the round where this transaction was confirmed.")]
        ulong @intraRoundOffset;
        
        [SerializeField, Tooltip(@"")]
        TransactionPayment @paymentTransaction;
        
        [SerializeField, Tooltip(@"")]
        TransactionKeyreg @keyregTransaction;
        
        [SerializeField, Tooltip(@"Round when the transaction was confirmed.")]
        ulong @confirmedRound;
        
        [SerializeField, Tooltip(@"[note] Free form data.")]
        string @note;
        
        [SerializeField, Tooltip(@"[rr] rewards applied to receiver account.")]
        ulong @receiverRewards;
        
        [SerializeField, Tooltip(@"Time when the block this transaction is in was confirmed.")]
        ulong @roundTime;
        
        [SerializeField, Tooltip(@"Inner transactions produced by application execution.")]
        Transaction[] @innerTxns;
        
        [SerializeField, Tooltip(@"")]
        TransactionAssetConfig @assetConfigTransaction;
        
        [SerializeField, Tooltip(@"[lv] Last valid round for this transaction.")]
        ulong @lastValid;
        
        [SerializeField, Tooltip(@"[rc] rewards applied to close-remainder-to account.")]
        ulong @closeRewards;
        
        [SerializeField, Tooltip(@"[ld] Local state key/value changes for the application being executed by this transaction.")]
        AccountStateDelta[] @localStateDelta;
        
        [SerializeField, Tooltip(@"Transaction ID")]
        string @id;
        
        [SerializeField, Tooltip(@"[sgnr] this is included with signed transactions when the signing address does not equal the sender. The backend can use this to ensure that auth addr is equal to the accounts auth addr.")]
        Address @authAddr;
        
        [SerializeField, Tooltip(@"[gen] genesis block ID.")]
        string @genesisId;
        
        [SerializeField, Tooltip(@"[snd] Sender's address.")]
        string @sender;
        
        [SerializeField, Tooltip(@"")]
        TransactionApplication @applicationTransaction;
        
        [SerializeField, Tooltip(@"Specifies an asset index (ID) if an asset was created with this transaction.")]
        ulong @createdAssetIndex;
        
        [SerializeField, Tooltip(@"[fv] First valid round for this transaction.")]
        ulong @firstValid;
        
        [SerializeField, Tooltip(@"[rekey] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.")]
        Address @rekeyTo;
        
        [SerializeField, Tooltip(@"")]
        TransactionAssetFreeze @assetFreezeTransaction;
        
        /// <summary>
        /// [fee] Transaction fee.        
        /// </summary>
        [AlgoApiField("fee")]
        public ulong Fee
        {
            get => this.@fee;
            set => this.@fee = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset-transfer-transaction")]
        public TransactionAssetTransfer AssetTransferTransaction
        {
            get => this.@assetTransferTransaction;
            set => this.@assetTransferTransaction = value;
        }

        /// <summary>
        /// [grp] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.        
        /// </summary>
        [AlgoApiField("group")]
        public string Group
        {
            get => this.@group;
            set => this.@group = value;
        }

        /// <summary>
        /// Specifies an application index (ID) if an application was created with this transaction.        
        /// </summary>
        [AlgoApiField("created-application-index")]
        public ulong CreatedApplicationIndex
        {
            get => this.@createdApplicationIndex;
            set => this.@createdApplicationIndex = value;
        }

        /// <summary>
        /// [lx] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.        
        /// </summary>
        [AlgoApiField("lease")]
        public string Lease
        {
            get => this.@lease;
            set => this.@lease = value;
        }

        /// <summary>
        /// [gh] Hash of genesis block.        
        /// </summary>
        [AlgoApiField("genesis-hash")]
        public string GenesisHash
        {
            get => this.@genesisHash;
            set => this.@genesisHash = value;
        }

        /// <summary>
        /// [lg] Logs for the application being executed by this transaction.        
        /// </summary>
        [AlgoApiField("logs")]
        public string[] Logs
        {
            get => this.@logs;
            set => this.@logs = value;
        }

        /// <summary>
        /// [rs] rewards applied to sender account.        
        /// </summary>
        [AlgoApiField("sender-rewards")]
        public ulong SenderRewards
        {
            get => this.@senderRewards;
            set => this.@senderRewards = value;
        }

        /// <summary>
        /// [ca] closing amount for transaction.        
        /// </summary>
        [AlgoApiField("closing-amount")]
        public ulong ClosingAmount
        {
            get => this.@closingAmount;
            set => this.@closingAmount = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("signature")]
        public TransactionSignature Signature
        {
            get => this.@signature;
            set => this.@signature = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("global-state-delta")]
        public StateDelta GlobalStateDelta
        {
            get => this.@globalStateDelta;
            set => this.@globalStateDelta = value;
        }

        /// <summary>
        /// [type] Indicates what type of transaction this is. Different types have different fields.
        /// 
        /// Valid types, and where their fields are stored:
        /// * [pay] payment-transaction
        /// * [keyreg] keyreg-transaction
        /// * [acfg] asset-config-transaction
        /// * [axfer] asset-transfer-transaction
        /// * [afrz] asset-freeze-transaction
        /// * [appl] application-transaction        
        /// </summary>
        [AlgoApiField("tx-type")]
        public TransactionType TxType
        {
            get => this.@txType;
            set => this.@txType = value;
        }

        /// <summary>
        /// Offset into the round where this transaction was confirmed.        
        /// </summary>
        [AlgoApiField("intra-round-offset")]
        public ulong IntraRoundOffset
        {
            get => this.@intraRoundOffset;
            set => this.@intraRoundOffset = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("payment-transaction")]
        public TransactionPayment PaymentTransaction
        {
            get => this.@paymentTransaction;
            set => this.@paymentTransaction = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("keyreg-transaction")]
        public TransactionKeyreg KeyregTransaction
        {
            get => this.@keyregTransaction;
            set => this.@keyregTransaction = value;
        }

        /// <summary>
        /// Round when the transaction was confirmed.        
        /// </summary>
        [AlgoApiField("confirmed-round")]
        public ulong ConfirmedRound
        {
            get => this.@confirmedRound;
            set => this.@confirmedRound = value;
        }

        /// <summary>
        /// [note] Free form data.        
        /// </summary>
        [AlgoApiField("note")]
        public string Note
        {
            get => this.@note;
            set => this.@note = value;
        }

        /// <summary>
        /// [rr] rewards applied to receiver account.        
        /// </summary>
        [AlgoApiField("receiver-rewards")]
        public ulong ReceiverRewards
        {
            get => this.@receiverRewards;
            set => this.@receiverRewards = value;
        }

        /// <summary>
        /// Time when the block this transaction is in was confirmed.        
        /// </summary>
        [AlgoApiField("round-time")]
        public ulong RoundTime
        {
            get => this.@roundTime;
            set => this.@roundTime = value;
        }

        /// <summary>
        /// Inner transactions produced by application execution.        
        /// </summary>
        [AlgoApiField("inner-txns")]
        public Transaction[] InnerTxns
        {
            get => this.@innerTxns;
            set => this.@innerTxns = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset-config-transaction")]
        public TransactionAssetConfig AssetConfigTransaction
        {
            get => this.@assetConfigTransaction;
            set => this.@assetConfigTransaction = value;
        }

        /// <summary>
        /// [lv] Last valid round for this transaction.        
        /// </summary>
        [AlgoApiField("last-valid")]
        public ulong LastValid
        {
            get => this.@lastValid;
            set => this.@lastValid = value;
        }

        /// <summary>
        /// [rc] rewards applied to close-remainder-to account.        
        /// </summary>
        [AlgoApiField("close-rewards")]
        public ulong CloseRewards
        {
            get => this.@closeRewards;
            set => this.@closeRewards = value;
        }

        /// <summary>
        /// [ld] Local state key/value changes for the application being executed by this transaction.        
        /// </summary>
        [AlgoApiField("local-state-delta")]
        public AccountStateDelta[] LocalStateDelta
        {
            get => this.@localStateDelta;
            set => this.@localStateDelta = value;
        }

        /// <summary>
        /// Transaction ID        
        /// </summary>
        [AlgoApiField("id")]
        public string Id
        {
            get => this.@id;
            set => this.@id = value;
        }

        /// <summary>
        /// [sgnr] this is included with signed transactions when the signing address does not equal the sender. The backend can use this to ensure that auth addr is equal to the accounts auth addr.        
        /// </summary>
        [AlgoApiField("auth-addr")]
        public Address AuthAddr
        {
            get => this.@authAddr;
            set => this.@authAddr = value;
        }

        /// <summary>
        /// [gen] genesis block ID.        
        /// </summary>
        [AlgoApiField("genesis-id")]
        public string GenesisId
        {
            get => this.@genesisId;
            set => this.@genesisId = value;
        }

        /// <summary>
        /// [snd] Sender's address.        
        /// </summary>
        [AlgoApiField("sender")]
        public string Sender
        {
            get => this.@sender;
            set => this.@sender = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("application-transaction")]
        public TransactionApplication ApplicationTransaction
        {
            get => this.@applicationTransaction;
            set => this.@applicationTransaction = value;
        }

        /// <summary>
        /// Specifies an asset index (ID) if an asset was created with this transaction.        
        /// </summary>
        [AlgoApiField("created-asset-index")]
        public ulong CreatedAssetIndex
        {
            get => this.@createdAssetIndex;
            set => this.@createdAssetIndex = value;
        }

        /// <summary>
        /// [fv] First valid round for this transaction.        
        /// </summary>
        [AlgoApiField("first-valid")]
        public ulong FirstValid
        {
            get => this.@firstValid;
            set => this.@firstValid = value;
        }

        /// <summary>
        /// [rekey] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.        
        /// </summary>
        [AlgoApiField("rekey-to")]
        public Address RekeyTo
        {
            get => this.@rekeyTo;
            set => this.@rekeyTo = value;
        }

        /// <summary>
        ///         
        /// </summary>
        [AlgoApiField("asset-freeze-transaction")]
        public TransactionAssetFreeze AssetFreezeTransaction
        {
            get => this.@assetFreezeTransaction;
            set => this.@assetFreezeTransaction = value;
        }

        public bool Equals(Transaction other)
        {
            return 
                Fee.Equals(other.Fee) &&
                AssetTransferTransaction.Equals(other.AssetTransferTransaction) &&
                StringComparer.Equals(Group, other.Group) &&
                CreatedApplicationIndex.Equals(other.CreatedApplicationIndex) &&
                StringComparer.Equals(Lease, other.Lease) &&
                StringComparer.Equals(GenesisHash, other.GenesisHash) &&
                ArrayComparer.Equals(Logs, other.Logs) &&
                SenderRewards.Equals(other.SenderRewards) &&
                ClosingAmount.Equals(other.ClosingAmount) &&
                Signature.Equals(other.Signature) &&
                GlobalStateDelta.Equals(other.GlobalStateDelta) &&
                TxType.Equals(other.TxType) &&
                IntraRoundOffset.Equals(other.IntraRoundOffset) &&
                PaymentTransaction.Equals(other.PaymentTransaction) &&
                KeyregTransaction.Equals(other.KeyregTransaction) &&
                ConfirmedRound.Equals(other.ConfirmedRound) &&
                StringComparer.Equals(Note, other.Note) &&
                ReceiverRewards.Equals(other.ReceiverRewards) &&
                RoundTime.Equals(other.RoundTime) &&
                ArrayComparer.Equals(InnerTxns, other.InnerTxns) &&
                AssetConfigTransaction.Equals(other.AssetConfigTransaction) &&
                LastValid.Equals(other.LastValid) &&
                CloseRewards.Equals(other.CloseRewards) &&
                ArrayComparer.Equals(LocalStateDelta, other.LocalStateDelta) &&
                StringComparer.Equals(Id, other.Id) &&
                AuthAddr.Equals(other.AuthAddr) &&
                StringComparer.Equals(GenesisId, other.GenesisId) &&
                StringComparer.Equals(Sender, other.Sender) &&
                ApplicationTransaction.Equals(other.ApplicationTransaction) &&
                CreatedAssetIndex.Equals(other.CreatedAssetIndex) &&
                FirstValid.Equals(other.FirstValid) &&
                RekeyTo.Equals(other.RekeyTo) &&
                AssetFreezeTransaction.Equals(other.AssetFreezeTransaction)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct AssetParams
        : IEquatable<AssetParams>
    {
        [SerializeField, Tooltip(@"[df] Whether holdings of this asset are frozen by default.")]
        bool @defaultFrozen;
        
        [SerializeField, Tooltip(@"The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.")]
        string @creator;
        
        [SerializeField, Tooltip(@"[dc] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).")]
        ulong @decimals;
        
        [SerializeField, Tooltip(@"[f] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.")]
        string @freeze;
        
        [SerializeField, Tooltip(@"[r] Address of account holding reserve (non-minted) units of this asset.")]
        string @reserve;
        
        [SerializeField, Tooltip(@"Base64 encoded name of a unit of this asset, as supplied by the creator.")]
        string @unitNameB64;
        
        [SerializeField, Tooltip(@"[an] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.")]
        string @name;
        
        [SerializeField, Tooltip(@"Base64 encoded URL where more information about the asset can be retrieved.")]
        string @urlB64;
        
        [SerializeField, Tooltip(@"[t] The total number of units of this asset.")]
        ulong @total;
        
        [SerializeField, Tooltip(@"[m] Address of account used to manage the keys of this asset and to destroy it.")]
        string @manager;
        
        [SerializeField, Tooltip(@"Base64 encoded name of this asset, as supplied by the creator.")]
        string @nameB64;
        
        [SerializeField, Tooltip(@"[au] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.")]
        string @url;
        
        [SerializeField, Tooltip(@"[un] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.")]
        string @unitName;
        
        [SerializeField, Tooltip(@"[c] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.")]
        string @clawback;
        
        [SerializeField, Tooltip(@"[am] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.")]
        string @metadataHash;
        
        /// <summary>
        /// [df] Whether holdings of this asset are frozen by default.        
        /// </summary>
        [AlgoApiField("default-frozen")]
        public bool DefaultFrozen
        {
            get => this.@defaultFrozen;
            set => this.@defaultFrozen = value;
        }

        /// <summary>
        /// The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.        
        /// </summary>
        [AlgoApiField("creator")]
        public string Creator
        {
            get => this.@creator;
            set => this.@creator = value;
        }

        /// <summary>
        /// [dc] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).        
        /// </summary>
        [AlgoApiField("decimals")]
        public ulong Decimals
        {
            get => this.@decimals;
            set => this.@decimals = value;
        }

        /// <summary>
        /// [f] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.        
        /// </summary>
        [AlgoApiField("freeze")]
        public string Freeze
        {
            get => this.@freeze;
            set => this.@freeze = value;
        }

        /// <summary>
        /// [r] Address of account holding reserve (non-minted) units of this asset.        
        /// </summary>
        [AlgoApiField("reserve")]
        public string Reserve
        {
            get => this.@reserve;
            set => this.@reserve = value;
        }

        /// <summary>
        /// Base64 encoded name of a unit of this asset, as supplied by the creator.        
        /// </summary>
        [AlgoApiField("unit-name-b64")]
        public string UnitNameB64
        {
            get => this.@unitNameB64;
            set => this.@unitNameB64 = value;
        }

        /// <summary>
        /// [an] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.        
        /// </summary>
        [AlgoApiField("name")]
        public string Name
        {
            get => this.@name;
            set => this.@name = value;
        }

        /// <summary>
        /// Base64 encoded URL where more information about the asset can be retrieved.        
        /// </summary>
        [AlgoApiField("url-b64")]
        public string UrlB64
        {
            get => this.@urlB64;
            set => this.@urlB64 = value;
        }

        /// <summary>
        /// [t] The total number of units of this asset.        
        /// </summary>
        [AlgoApiField("total")]
        public ulong Total
        {
            get => this.@total;
            set => this.@total = value;
        }

        /// <summary>
        /// [m] Address of account used to manage the keys of this asset and to destroy it.        
        /// </summary>
        [AlgoApiField("manager")]
        public string Manager
        {
            get => this.@manager;
            set => this.@manager = value;
        }

        /// <summary>
        /// Base64 encoded name of this asset, as supplied by the creator.        
        /// </summary>
        [AlgoApiField("name-b64")]
        public string NameB64
        {
            get => this.@nameB64;
            set => this.@nameB64 = value;
        }

        /// <summary>
        /// [au] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.        
        /// </summary>
        [AlgoApiField("url")]
        public string Url
        {
            get => this.@url;
            set => this.@url = value;
        }

        /// <summary>
        /// [un] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.        
        /// </summary>
        [AlgoApiField("unit-name")]
        public string UnitName
        {
            get => this.@unitName;
            set => this.@unitName = value;
        }

        /// <summary>
        /// [c] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.        
        /// </summary>
        [AlgoApiField("clawback")]
        public string Clawback
        {
            get => this.@clawback;
            set => this.@clawback = value;
        }

        /// <summary>
        /// [am] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.        
        /// </summary>
        [AlgoApiField("metadata-hash")]
        public string MetadataHash
        {
            get => this.@metadataHash;
            set => this.@metadataHash = value;
        }

        public bool Equals(AssetParams other)
        {
            return 
                DefaultFrozen.Equals(other.DefaultFrozen) &&
                StringComparer.Equals(Creator, other.Creator) &&
                Decimals.Equals(other.Decimals) &&
                StringComparer.Equals(Freeze, other.Freeze) &&
                StringComparer.Equals(Reserve, other.Reserve) &&
                StringComparer.Equals(UnitNameB64, other.UnitNameB64) &&
                StringComparer.Equals(Name, other.Name) &&
                StringComparer.Equals(UrlB64, other.UrlB64) &&
                Total.Equals(other.Total) &&
                StringComparer.Equals(Manager, other.Manager) &&
                StringComparer.Equals(NameB64, other.NameB64) &&
                StringComparer.Equals(Url, other.Url) &&
                StringComparer.Equals(UnitName, other.UnitName) &&
                StringComparer.Equals(Clawback, other.Clawback) &&
                StringComparer.Equals(MetadataHash, other.MetadataHash)
                ;
        }
    }

    [AlgoApiObject, Serializable]
    public partial struct BlockUpgradeState
        : IEquatable<BlockUpgradeState>
    {
        [SerializeField, Tooltip(@"[proto] The current protocol version.")]
        string @currentProtocol;
        
        [SerializeField, Tooltip(@"[nextproto] The next proposed protocol version.")]
        string @nextProtocol;
        
        [SerializeField, Tooltip(@"[nextyes] Number of blocks which approved the protocol upgrade.")]
        ulong @nextProtocolApprovals;
        
        [SerializeField, Tooltip(@"[nextswitch] Round on which the protocol upgrade will take effect.")]
        ulong @nextProtocolSwitchOn;
        
        [SerializeField, Tooltip(@"[nextbefore] Deadline round for this protocol upgrade (No votes will be consider after this round).")]
        ulong @nextProtocolVoteBefore;
        
        /// <summary>
        /// [proto] The current protocol version.        
        /// </summary>
        [AlgoApiField("current-protocol")]
        public string CurrentProtocol
        {
            get => this.@currentProtocol;
            set => this.@currentProtocol = value;
        }

        /// <summary>
        /// [nextproto] The next proposed protocol version.        
        /// </summary>
        [AlgoApiField("next-protocol")]
        public string NextProtocol
        {
            get => this.@nextProtocol;
            set => this.@nextProtocol = value;
        }

        /// <summary>
        /// [nextyes] Number of blocks which approved the protocol upgrade.        
        /// </summary>
        [AlgoApiField("next-protocol-approvals")]
        public ulong NextProtocolApprovals
        {
            get => this.@nextProtocolApprovals;
            set => this.@nextProtocolApprovals = value;
        }

        /// <summary>
        /// [nextswitch] Round on which the protocol upgrade will take effect.        
        /// </summary>
        [AlgoApiField("next-protocol-switch-on")]
        public ulong NextProtocolSwitchOn
        {
            get => this.@nextProtocolSwitchOn;
            set => this.@nextProtocolSwitchOn = value;
        }

        /// <summary>
        /// [nextbefore] Deadline round for this protocol upgrade (No votes will be consider after this round).        
        /// </summary>
        [AlgoApiField("next-protocol-vote-before")]
        public ulong NextProtocolVoteBefore
        {
            get => this.@nextProtocolVoteBefore;
            set => this.@nextProtocolVoteBefore = value;
        }

        public bool Equals(BlockUpgradeState other)
        {
            return 
                StringComparer.Equals(CurrentProtocol, other.CurrentProtocol) &&
                StringComparer.Equals(NextProtocol, other.NextProtocol) &&
                NextProtocolApprovals.Equals(other.NextProtocolApprovals) &&
                NextProtocolSwitchOn.Equals(other.NextProtocolSwitchOn) &&
                NextProtocolVoteBefore.Equals(other.NextProtocolVoteBefore)
                ;
        }
    }

    /// <summary>
    /// Application state delta.    
    /// </summary>
    [Serializable, AlgoApiFormatter(typeof(WrappedValueFormatter<StateDelta, EvalDeltaKeyValue[]>))]
    public partial struct StateDelta
        : IEquatable<StateDelta>
        , IWrappedValue<EvalDeltaKeyValue[]>
    {
        [SerializeField]
        EvalDeltaKeyValue[] @value;

        public StateDelta(EvalDeltaKeyValue[] value)
        {
            this.@value = value;
        }

        public EvalDeltaKeyValue[] WrappedValue
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(StateDelta other)
        {
            return ArrayComparer.Equals(WrappedValue, other.WrappedValue);
        }
        
        public static implicit operator EvalDeltaKeyValue[](StateDelta wrapper)
        {
            return wrapper.WrappedValue;
        }

        public static implicit operator StateDelta(EvalDeltaKeyValue[] value)
        {
            return new StateDelta(value);
        }
    }
    
    /// <summary>
    /// Represents a key-value store for use in an application.    
    /// </summary>
    [Serializable, AlgoApiFormatter(typeof(WrappedValueFormatter<TealKeyValueStore, TealKeyValue[]>))]
    public partial struct TealKeyValueStore
        : IEquatable<TealKeyValueStore>
        , IWrappedValue<TealKeyValue[]>
    {
        [SerializeField]
        TealKeyValue[] @value;

        public TealKeyValueStore(TealKeyValue[] value)
        {
            this.@value = value;
        }

        public TealKeyValue[] WrappedValue
        {
            get => this.@value;
            set => this.@value = value;
        }

        public bool Equals(TealKeyValueStore other)
        {
            return ArrayComparer.Equals(WrappedValue, other.WrappedValue);
        }
        
        public static implicit operator TealKeyValue[](TealKeyValueStore wrapper)
        {
            return wrapper.WrappedValue;
        }

        public static implicit operator TealKeyValueStore(TealKeyValue[] value)
        {
            return new TealKeyValueStore(value);
        }
    }
    
}
